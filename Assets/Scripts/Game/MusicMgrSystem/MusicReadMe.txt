注意，配置表中的标志声音的枚举类型必须要和枚举完全一致，这样枚举在被json转换的时候才能自动转换成相应类型

使用：
    配置表中配置数据，声音管理器中使用json加载数据并存储；
    外界掉用对应方法来播放或者得到对应的clip，传入对应的枚举类型
    管理器根据这个枚举查找加载的配置表数据，根据这个数据得到ab包名和路径名（一般是资源名）
    查询是否加载并保存过这个声音，若无则向ab包提供信息进行加载，若有则返回该clip

所有的挂载在物体上的音效组件都要注册到声音管理器中
UI面板的音效通过SoundMgr来播放
全局声音数据通过声音管理器管理 

声音管理器加载所有需要的声音并保存，其他的物体需要播放声音通过向声音管理器进行指定获取对应的音效资源

声音加载：
    通过json序列化配置表数据，声音管理器进行存储
    数据把声音枚举类型绑定在一起，记录路径和ab包名
    外界请求播放的时候输入枚举类型，表示是哪个音效
    管理器根据这个枚举查找加载的配置表数据，根据这个数据得到ab包名和路径名（一般是资源名）
    然后让ab包管理器进行加载

三种模式
UI和背景音乐通过SoundMgr来播放
频繁的固定位置的音效播放时通过挂载脚本来播放的
其他的通过创建一个空物体挂载一个audiosource组件然后播放


通过枚举表示各个音效资源

第一种模式：
    这种模式中UI是特别的，因为他归属于音效的范围却被管理着bgm的声音管理器直接管辖
    所以在声音管理器上添加两个audiosource，然后把ui的添加到音效的哈希表中，接受音效的统一管辖

第三种模式：
    通过向对象池申请对象，在对应位置播放，没有封装工厂，因为没有必要
    对象池创建一个空物体的逻辑：创建空物体，添加audiosource组件，playeronawake设置为false返回出去
    并不会被添加到音效表中而是激活的时候同时同步音效状态